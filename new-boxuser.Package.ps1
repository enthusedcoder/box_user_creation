#------------------------------------------------------------------------
# Source File Information (DO NOT MODIFY)
# Source ID: 4345565c-1212-4175-9f39-c3d33c487635
# Source File: C:\Users\whiggs\Documents\technology operations\EE PowerShell\new-boxuser\new-boxuser.psproj
#------------------------------------------------------------------------
#region Project Recovery Data (DO NOT MODIFY)
<#RecoveryData:
TwIAAB+LCAAAAAAABACFUltvgjAYfTfxP5A+LkFEQGeGfVgMiw+7RMxel1o+BltpSVu87NevUDSa
bdnL1572cE7OofEaqNiBPC6JJng4cJz4RYoPoNpJj5wWUvDyC7IFSghTgLrDpGQa5ALdjGrl37Wz
sktmF/9QsW6Td1OZaU8KYPVIHzTqjIzVK0hVCo4nIz/2TqC/My6wWuIwCKNoGlHXn/gTN/RnkTvP
g7lLgywIaHg7mwZR7PXk/tM+weZYAx7H3iU8iQuWGTvHu3RTPeihc9+UzCQfI5xqInVTt2Gs119M
Jy2IbOvayMa0tYYcJHAKScOpNuEWaMV34hPcBya2hL2ZshC2e9U294/6L3ppIfbuIyl5ImRl9HKE
T6j9A1eCFtiY51osepble8kJawlPpALMYe9uxaFRII1Obbix94M0HMTe1QP6Bvt3MwtPAgAA#>
#endregion
<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2019 v5.6.160
     Generated on:       4/16/2019 1:41 AM
     Generated by:       whiggs
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2019
#>



#region Source: Startup.pss
#region File Recovery Data (DO NOT MODIFY)
<#RecoveryData:
XwAAAB+LCAAAAAAABACzCUpNzi9LLap0SSxJVAAyijPz82yVjPUMley4FBRs/Isy0zPzEnPcMnNS
/RJzU+2CSxKLSkoL9AqKi230MWS5bPSRDbQDAHEtMNxfAAAA#>
#endregion
#----------------------------------------------
#region Import Assemblies
#----------------------------------------------
#endregion Import Assemblies

#Define a Param block to use custom parameters in the project
#Param ($CustomParameter)

function Main {
<#
    .SYNOPSIS
        The Main function starts the project application.
    
    .PARAMETER Commandline
        $Commandline contains the complete argument string passed to the script packager executable.
    
    .NOTES
        Use this function to initialize your script and to call GUI forms.
		
    .NOTES
        To get the console output in the Packager (Forms Engine) use: 
		$ConsoleOutput (Type: System.Collections.ArrayList)
#>
	Param ([String]$Commandline)
		
	#--------------------------------------------------------------------------
	#TODO: Add initialization script here (Load modules and check requirements)
	#Get-Handle -Name "$env:ProgramFiles\WindowsPowerShell\Modules\DepartModule" | Close-Handle -Confirm:$false -ErrorAction SilentlyContinue
	#Get-Handle -Name "$env:ProgramFiles\WindowsPowerShell\Modules\DepartModule\*" | Close-Handle -Confirm:$false -ErrorAction SilentlyContinue
	#--------------------------------------------------------------------------
	Remove-Item "$env:ProgramFiles\WindowsPowerShell\Modules\DepartModule" -Force -Recurse
	Remove-Module Departmodule
	Remove-Item "$env:ProgramFiles\WindowsPowerShell\Modules\DepartModule" -Force -Recurse
	if((Show-MainForm_psf) -eq 'OK')
	{
		
	}
	
	$script:ExitCode = 0 #Set the exit code for the Packager
}


#endregion Source: Startup.pss

#region Source: Globals.ps1
	#--------------------------------------------
	# Declare Global Variables and Functions here
	#--------------------------------------------
	
	
	#Sample function that provides the location of the script
	function Get-ScriptDirectory
	{
	<#
		.SYNOPSIS
			Get-ScriptDirectory returns the proper location of the script.
	
		.OUTPUTS
			System.String
		
		.NOTES
			Returns the correct path within a packaged executable.
	#>
		[OutputType([string])]
		param ()
		if ($hostinvocation -ne $null)
		{
			return Split-Path $hostinvocation.MyCommand.path
		}
		else
		{
			return Split-Path $script:MyInvocation.MyCommand.Path
		}
	}
	function Get-Scriptname
	{
	<#
		.SYNOPSIS
			Get-ScriptDirectory returns the proper location of the script.
	
		.OUTPUTS
			System.String
		
		.NOTES
			Returns the correct path within a packaged executable.
	#>
		[OutputType([string])]
		param ()
		if ($hostinvocation -ne $null)
		{
			return $hostinvocation.MyCommand.Name
		}
		else
		{
			return $script:MyInvocation.MyCommand.Name
		}
	}
	$JobTrackerList = New-Object System.Collections.ArrayList
	function Add-JobTracker
	{
			<#
				.SYNOPSIS
					Add a new job to the JobTracker and starts the timer.
			
				.DESCRIPTION
					Add a new job to the JobTracker and starts the timer.
			
				.PARAMETER  Name
					The name to assign to the Job
			
				.PARAMETER  JobScript
					The script block that the Job will be performing. 
					Important: Do not access form controls from this script block.
			
				.PARAMETER ArgumentList
					The arguments to pass to the job
			
				.PARAMETER  CompleteScript
					The script block that will be called when the job is complete.
					The job is passed as an argument. The Job argument is null when the job fails.
			
				.PARAMETER  UpdateScript
					The script block that will be called each time the timer ticks. 
					The job is passed as an argument. Use this to get the Job's progress.
			
				.EXAMPLE
					Job-Begin -Name "JobName" `
					-JobScript {	
						#Important: Do not access form controls from this script block.
						Get-WmiObject Win32_Process -Namespace "root\CIMV2"
					}`
					-CompletedScript {
						Param($Job)		
						$results = Receive-Job -Job $Job		
					}`
					-UpdateScript {
						Param($Job)
						#$results = Receive-Job -Job $Job -Keep
					}
			
				.LINK
					
			#>
		
		Param (
			[ValidateNotNull()]
			[Parameter(Mandatory = $true)]
			[string]$Name,
			[ValidateNotNull()]
			[Parameter(Mandatory = $true)]
			[ScriptBlock]$JobScript,
			$ArgumentList = $null,
			[ScriptBlock]$CompletedScript,
			[ScriptBlock]$UpdateScript)
		
		#Start the Job
		$job = Start-Job -Name $Name -ScriptBlock $JobScript -ArgumentList $ArgumentList
		
		if ($job -ne $null)
		{
			#Create a Custom Object to keep track of the Job & Script Blocks
			$psObject = New-Object System.Management.Automation.PSObject
			
			Add-Member -InputObject $psObject -MemberType 'NoteProperty' -Name Job -Value $job
			Add-Member -InputObject $psObject -MemberType 'NoteProperty' -Name CompleteScript -Value $CompletedScript
			Add-Member -InputObject $psObject -MemberType 'NoteProperty' -Name UpdateScript -Value $UpdateScript
			
			[void]$JobTrackerList.Add($psObject)
			
			#Start the Timer
			if (-not $timerJobTracker.Enabled)
			{
				$timerJobTracker.Start()
			}
		}
		elseif ($CompletedScript -ne $null)
		{
			#Failed
			Invoke-Command -ScriptBlock $CompletedScript -ArgumentList $null
		}
		
	}
	
	function Update-JobTracker
	{
			<#
				.SYNOPSIS
					Checks the status of each job on the list.
			#>
		
		#Poll the jobs for status updates
		$timerJobTracker.Stop() #Freeze the Timer
		
		for ($index = 0; $index -lt $JobTrackerList.Count; $index++)
		{
			$psObject = $JobTrackerList[$index]
			
			if ($psObject -ne $null)
			{
				if ($psObject.Job -ne $null)
				{
					if ($psObject.Job.State -ne "Running")
					{
						#Call the Complete Script Block
						if ($psObject.CompleteScript -ne $null)
						{
							#$results = Receive-Job -Job $psObject.Job
							Invoke-Command -ScriptBlock $psObject.CompleteScript -ArgumentList $psObject.Job
						}
						
						$JobTrackerList.RemoveAt($index)
						Remove-Job -Job $psObject.Job
						$index-- #Step back so we don't skip a job
					}
					elseif ($psObject.UpdateScript -ne $null)
					{
						#Call the Update Script Block
						Invoke-Command -ScriptBlock $psObject.UpdateScript -ArgumentList $psObject.Job
					}
				}
			}
			else
			{
				$JobTrackerList.RemoveAt($index)
				$index-- #Step back so we don't skip a job
			}
		}
		
		if ($JobTrackerList.Count -gt 0)
		{
			$timerJobTracker.Start() #Resume the timer	
		}
	}
	function Stop-JobTracker
	{
			<#
				.SYNOPSIS
					Stops and removes all Jobs from the list.
			#>
		#Stop the timer
		$timerJobTracker.Stop()
		
		#Remove all the jobs
		while ($JobTrackerList.Count -gt 0)
		{
			$job = $JobTrackerList[0].Job
			$JobTrackerList.RemoveAt(0)
			Stop-Job $job
			Remove-Job $job
		}
	}#endregion
	function Search-User
	{
		
		$DialogPicker = New-Object CubicOrange.Windows.Forms.ActiveDirectory.DirectoryObjectPickerDialog
		
		$DialogPicker.AllowedLocations = [CubicOrange.Windows.Forms.ActiveDirectory.Locations]::All
		$DialogPicker.AllowedObjectTypes = [CubicOrange.Windows.Forms.ActiveDirectory.ObjectTypes]::Users
		$DialogPicker.DefaultLocations = [CubicOrange.Windows.Forms.ActiveDirectory.Locations]::JoinedDomain
		$DialogPicker.DefaultObjectTypes = [CubicOrange.Windows.Forms.ActiveDirectory.ObjectTypes]::Users
		$DialogPicker.ShowAdvancedView = $false
		$DialogPicker.MultiSelect = $true
		$DialogPicker.SkipDomainControllerCheck = $true
		$DialogPicker.Providers = [CubicOrange.Windows.Forms.ActiveDirectory.ADsPathsProviders]::Default
		
		$DialogPicker.AttributesToFetch.Add('samAccountName')
		#$DialogPicker.AttributesToFetch.Add('title')
		#$DialogPicker.AttributesToFetch.Add('department')
		#$DialogPicker.AttributesToFetch.Add('distinguishedName')
		
		
		$DialogPicker.ShowDialog()
		
		return $DialogPicker.Selectedobject
	}
	
	
	#Sample variable that provides the location of the script
	[string]$ScriptDirectory = Get-ScriptDirectory
	[String]$scriptname = (Get-Scriptname).TrimEnd('.exe')
	
	$globaladmin = 'nono@none.com'
	$encrps = '01000000d08c9ddf0115d1118c7a00c04fc297eb0100000028d7b2235847f24cb369f8ded890ced00000000002000000000003660000c00000001000000001ee706b06cac8af78732a0ced39bc510000000004800000a000000010000000f85ed20825a82cd98b4ac8b44de2c79b10000000338df40b6b652d4831b487d48335b6bb1400000092de84f2cb0a96aca4abff9f3ae2622da9665b29'
	$key = (3, 4, 2, 3, 56, 34, 254, 222, 1, 1, 2, 23, 42, 54, 33, 233, 1, 34, 2, 7, 6, 5, 35, 43)
	$global:totalcount = 0
	$global:removecount = 0
	$repusername = "usertoken"
	$reppass = 'ww3hihtbn2ovflnughytuc4ar37sriyp5xftmqpecd2ootiepi2q'
	
	
#endregion Source: Globals.ps1

#region Source: MainForm.psf
function Show-MainForm_psf
{
#region File Recovery Data (DO NOT MODIFY)
<#RecoveryData:
OwgAAB+LCAAAAAAABABllseO6zoShvd6isbd6uAoWQnoPoCyrGjZCrZ2yjlTVnj66b4zmLnAkBuS
xWKRRP346vOeJcM7mw8xAtHH92Cphv7rL+I39tcf6OPj056rouqjVq7azIq67I8ZVb08zN3vcck/
kf8z//j8mP/0Zl1iMLq9joXjBFsUuH83nhPTbsVcpi6czUDyJ6mO4RaOkSd3Ld/y7ySh86ezjDuc
ojr1MM970k1G8iTgGJLXRzoOiFC4tZgqBw6TWp6eiabRefo+ZCfJTcJpqCOiNIU7KwyRlWWQWTiU
pYFYjWMMRZY2gOQDdIIaJ3PM++0++etKGcwjeqSJdtfsK1p5o7FL9HhdQ0bJTXu6+pfSXhGPYh39
HdbZZLQPW9kjLeIZ7AbfTihYDXbe60Z8EYOAOKVXvrRsOFRpDRYwVJ4sHjiw/IElUY8j+cnSXsiD
dDeOmcteVxpQtCrWzNI8XhLIfcXdw6Kukn52WjZrEt6eJYhJWmYSmn0C6S0nFop0GkHGZ+iv5NDi
FxkL3btTC8l0R/qZrw4VTo+jhUKqtu7OWSqzf0N3qb9TfVNNaSLQY/AEcNwyhzqF3qBFOriwdwtL
d/G5bbwYsx3nXXmFKKP6Pcp3AyQQD8MPpiwCh0YZpB0kX1d3H9h7vSvao7JybbAqEKskWnZcCjwg
BYnG7N4LzUhfNq90BQplwG6DOdlXKBzguBuC710+UpgqB9u9SnD21D52agmHtAsL9vJSZSELYOU7
6dBMwIy4ciLG74vEJ0yiTGXW7ln7wkALmoTAfElP2nrdXP6Cn7Oo8p7lhXIqyKvpW/ptfKf7zvvR
mnS1azuqpx0t/WwwyymtdUh7R2UERV5SaBRi1CtvDkGZIXWBUfiVz3Vug7fewjqOJDEcWIBRYkTb
Y2DtqTaeeXUmuW2HBsq48Iq7pfVaCqt8XqDNM66+/vDBkxtBiS3ci7GOFgsql33MXb+z6U5VvpM2
xEDNMeUX9dPzMZf370g8lzFKaeL46IqX4OMDNNsvUjfHSy+b5HKWYqfNIQ3U4Z7dNinUez9PEB8d
Cbw4KUd5OjgmGZQV3QUWxEHpL3EhnRJKhBOxDtA2iVqvaT9SBd9StfDICozzRur7wNBOhtfyW/Um
JZv7kkiHR0P7309xm/3c7+p4Ua/2FpFxMtdMehUg0HOnO785wMJadOB50Bxdt+1jZ+6ZQKPGy/Xf
gcDLhnbxmaDxpB3JZyVLNmYsoizIg81kT7pQ5l7HIVzRUYlzsSdWGUoLfEtSQbo1dIXfcGnFKhM2
Z/hpJv2zSArUOYLt3efiUzkZ5Vv7hcO+5Py8P5BTFwE0xLmM18XzoJihcdf2DWp4P1IaDC9epO2X
MjFeaqSBIUpRaB/mKWqwOIwqvIkxUK7e2d5zgEXSNHQ4hNxUYrUrpM7ra3p7HaK++lvhU3BQ1jW9
oqC4J4ZgPkNUKpoBUx+393N0PVMHqdnQ8TARnW9Yx9jt2xsajWZYjhagwwHwfnJBc4OrcS/jsueC
RuKiDW0WXuDWRxZGbKb70YMNhpJrGCknKTfSW0OaBVZm7HOFqFXreQqpzWZiH9e6lseAcEghqUuu
Z5z4QW9qv8updpgPz4nYRGcX7LpNdXkztexl721F+VdwOw7W0yGS8bDMak5Bjgcjvu9Rr01d/ooO
sfKR414w0mhWrvxK7CpUF9jAUlfF3brcAeFd8WDqk/LibBl6vbop1MDh7AYwdeKdhQDEx/hukIYG
E6gEbIklVB5OEGvonMg49yaTKHiD4/IU2463nUHiI7y4u/ypTugeQD2t2gkX8rB63uILvRCqB7+N
hbzJgHyLP4kXoJZjkW8mJUNdnSj/ID3NtDXHsPeiTFihr8dK3sTTkSDshZa2lYDYijVjxr7Rod3t
lL+ut+6+8lKZ4XF+291sb8ULt8/cMR/06JZooDIq5/PRscMVTkpoxnkkJCTqQjRoT8RjqNxqr0sR
HveRHquezIRWvCrrNpmus2HSPlyKr+//yJ/m00I24WkdTfw3Krmvr0/kb4L+oJRblqyL2ypbfqb/
Wzj+PI4FZN3voOrTYVt+/3gsvz78/wD88hv96b8+hLUF65x99dkK5qj99XFbv49L9Oxwhybrv2Ka
jsiEpDCWuGQow34i/43wEx/55wU+kX8WC3/+BTlj7lA7CAAA#>
#endregion
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Define SAPIEN Types
	#----------------------------------------------
	try{
		[ProgressBarOverlay] | Out-Null
	}
	catch
	{
		Add-Type -ReferencedAssemblies ('System.Windows.Forms', 'System.Drawing') -TypeDefinition  @" 
		using System;
		using System.Windows.Forms;
		using System.Drawing;
        namespace SAPIENTypes
        {
		    public class ProgressBarOverlay : System.Windows.Forms.ProgressBar
	        {
                public ProgressBarOverlay() : base() { SetStyle(ControlStyles.OptimizedDoubleBuffer | ControlStyles.AllPaintingInWmPaint, true); }
	            protected override void WndProc(ref Message m)
	            { 
	                base.WndProc(ref m);
	                if (m.Msg == 0x000F)// WM_PAINT
	                {
	                    if (Style != System.Windows.Forms.ProgressBarStyle.Marquee || !string.IsNullOrEmpty(this.Text))
                        {
                            using (Graphics g = this.CreateGraphics())
                            {
                                using (StringFormat stringFormat = new StringFormat(StringFormatFlags.NoWrap))
                                {
                                    stringFormat.Alignment = StringAlignment.Center;
                                    stringFormat.LineAlignment = StringAlignment.Center;
                                    if (!string.IsNullOrEmpty(this.Text))
                                        g.DrawString(this.Text, this.Font, Brushes.Black, this.ClientRectangle, stringFormat);
                                    else
                                    {
                                        int percent = (int)(((double)Value / (double)Maximum) * 100);
                                        g.DrawString(percent.ToString() + "%", this.Font, Brushes.Black, this.ClientRectangle, stringFormat);
                                    }
                                }
                            }
                        }
	                }
	            }
              
                public string TextOverlay
                {
                    get
                    {
                        return base.Text;
                    }
                    set
                    {
                        base.Text = value;
                        Invalidate();
                    }
                }
	        }
        }
"@ -IgnoreWarnings | Out-Null
	}
	#endregion Define SAPIEN Types

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$formBoxUserManagement = New-Object 'System.Windows.Forms.Form'
	$buttonRemoveBoxLicense = New-Object 'System.Windows.Forms.Button'
	$listview1 = New-Object 'System.Windows.Forms.ListView'
	$buttonSearch = New-Object 'System.Windows.Forms.Button'
	$textbox2 = New-Object 'System.Windows.Forms.TextBox'
	$labelRemoveBoxLicense = New-Object 'System.Windows.Forms.Label'
	$buttonAssignLicense = New-Object 'System.Windows.Forms.Button'
	$button1 = New-Object 'System.Windows.Forms.Button'
	$textbox1 = New-Object 'System.Windows.Forms.TextBox'
	$labelCreateBoxAccount = New-Object 'System.Windows.Forms.Label'
	$labelBoxUserManagement = New-Object 'System.Windows.Forms.Label'
	$progressbaroverlay1 = New-Object 'SAPIENTypes.ProgressBarOverlay'
	$labelaccount = New-Object 'System.Windows.Forms.Label'
	$columnheader1 = New-Object 'System.Windows.Forms.ColumnHeader'
	$columnheader2 = New-Object 'System.Windows.Forms.ColumnHeader'
	$columnheader3 = New-Object 'System.Windows.Forms.ColumnHeader'
	$columnheader4 = New-Object 'System.Windows.Forms.ColumnHeader'
	$columnheader5 = New-Object 'System.Windows.Forms.ColumnHeader'
	$timerJobTracker = New-Object 'System.Windows.Forms.Timer'
	$timer1 = New-Object 'System.Windows.Forms.Timer'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	$formBoxUserManagement_Load={
		#TODO: Initialize Form Controls here
		$progressbaroverlay1.Visible = $true
		Add-JobTracker -Name "Startup" -JobScript {
			param ($scriptdir,
				$scriptnamee
			)
			$sec = ConvertTo-SecureString 'ww3hihtbn2ovflnughytuc4ar37sriyp5xftmqpecd2ootiepi2q' -AsPlainText -Force
			$necred = New-Object System.Management.Automation.PSCredential -ArgumentList "usertoken", $sec
			Get-PackageProvider -Name NuGet -ForceBootstrap -Force
			Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
				<#
				Try
				{
					Import-Module Poshinternals -Force -ErrorAction Stop
					Get-Handle -Name "$env:ProgramFiles\WindowsPowerShell\Modules\DepartModule\*" | Close-Handle -Confirm:$false -ErrorAction SilentlyContinue
					Get-ChildItem "$env:ProgramFiles\WindowsPowerShell\Modules\DepartModule\*.json" -Recurse | % { Remove-Item $_.FullName -Force }
				}
				Catch
				{
					Install-Module PoshInternals -AllowClobber -Force -Repository "PSGallery"
					Import-Module Poshinternals -Force
					Get-ChildItem "$env:ProgramFiles\WindowsPowerShell\Modules\DepartModule\*.json" -Recurse | % { Get-Handle -Name $_.FullName | Close-Handle -Confirm:$false -ErrorAction SilentlyContinue }
					Get-ChildItem "$env:ProgramFiles\WindowsPowerShell\Modules\DepartModule\*.json" -Recurse | % { Remove-Item $_.FullName -Force }
				}
				#>
			#$restart = $false
			#If (!(Test-Path $env:ProgramData\chocolatey\bin\NuGet.exe))
			#{
			#	$restart = $true
			#}
			#install chocolatey
			iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
			import-module "C:\ProgramData\chocolatey\helpers\chocolateyInstaller.psm1" -Force
			Update-SessionEnvironment
			#install the latest version of the departmodule from the VSTS package feed.
			choco upgrade NuGet.commandline -y
			Update-SessionEnvironment
			NuGet update -self
			Install-Module Packagemanagement -AllowClobber -Force
			Install-Module Powershellget -Repository PSGallery -RequiredVersion 1.5.0.0 -Force -AllowClobber
			Remove-Module powershellget -Force
			Import-Module powershellget -RequiredVersion 1.5.0.0 -Force
			$repsource = Get-PackageSource -PackageManagementProvider Nuget -ProviderName PowerShellGet -Force -ForceBootstrap
			If ($repsource.Name -notcontains "EE")
			{
				NuGet Sources Add -Name "EE" -Source "https://vstssite.pkgs.visualstudio.com/_packaging/EE/nuget/v2/" -Username "usertoken" -Password 'ww3hihtbn2ovflnughytuc4ar37sriyp5xftmqpecd2ootiepi2q' -storePasswordInClearText
			}
			$psrep = Get-PSRepository -Name "EE" -ErrorAction SilentlyContinue
			if ($psrep -eq $null)
			{
				Register-PSRepository -Name "EE" -SourceLocation "https://vstssite.pkgs.visualstudio.com/_packaging/EE/nuget/v2/" -Credential $necred -InstallationPolicy Trusted
			}
			$instmodule = $null
			$repmodule = $null
			#test to see if the departmodule is already present on the system.  If it is,
			#uninstall it.
			If (Test-Path $env:ProgramFiles\WindowsPowerShell\Modules\DepartModule)
			{
				$instmodule = Get-InstalledModule -Name Departmodule
				$repmodule = Find-Module -Name DepartModule -Repository EE -Credential $necred
				If ([System.Version]$repmodule.Version -gt [System.Version]$instmodule.Version)
				{
					Remove-Module DepartModule -Force
					Uninstall-Module Departmodule -Force -AllVersions
					Install-Module DepartModule -Repository "EE" -Force -AllowClobber -Credential $necred
				}
			}
			Else
			{
				Install-Module DepartModule -Repository "EE" -Force -AllowClobber -Credential $necred
			}
			
			
			Import-Module DepartModule -Force
			#test to see if the Remote server administration tools are installed on the system.
			#If they are not, install them.
			Try
			{
				Import-Module Activedirectory -ErrorAction Stop
			}
			Catch
			{
				$wmi = Get-WmiObject -Class Win32_OperatingSystem -Namespace Root\cimv2 -Property "caption"
				If ($wmi.caption -like "*server*")
				{
					Add-WindowsFeature -Name RSAT-AD-Tools
					Add-windowsFeature -Name RSAT-AD-PowerShell
					Import-Module ActiveDirectory
				}
				Else
				{
					Install-RSATTools
					Import-Module ActiveDirectory
				}
			}
			#install posh-syslog powershell module, which allows powershell to create event logs
			#on a syslog server
	
			If (!(Test-Path "$env:ProgramFiles\WindowsPowerShell\Modules\AzureRM.KeyVault"))
			{
				Install-Module AzureRm -AllowClobber -Force -Repository "PSGallery"
			}
			else
			{
				$needsup = $true
				$vercheck = Find-module Azurerm -Repository PSGallery
				$curmod = Get-module -ListAvailable -Name Azurerm
				Foreach ($cur in $curmod)
				{
					If ([System.Version]$cur.Version -eq [System.Version]$vercheck.Version)
					{
						$needsup = $false
						Break
					}
					Else
					{
						Continue
					}
				}
				If ($needsup)
				{
					Update-module Azurerm -Force
				}
				Else
				{
					Write-Host "All good."
				}
			}
			If (!(Test-Path "$env:ProgramFiles\WindowsPowerShell\Modules\PoshInternals"))
			{
				Install-Module PoshInternals -AllowClobber -Force -Repository "PSGallery"
			}
			Else
			{
				$needsup = $true
				$vercheck = Find-module PoshInternals -Repository PSGallery
				$curmod = Get-module -ListAvailable -Name PoshInternals
				Foreach ($cur in $curmod)
				{
					If ([System.Version]$cur.Version -eq [System.Version]$vercheck.Version)
					{
						$needsup = $false
						Break
					}
					Else
					{
						Continue
					}
				}
				If ($needsup)
				{
					Update-Module PoshInternals -Force
				}
				Else
				{
					Write-Host "All good"
				}
			}
			If (!(Test-Path $env:ProgramFiles\WindowsPowerShell\Modules\SharePointPnPPowerShellOnline))
			{
				Install-Module SharePointPnPPowerShellOnline -AllowClobber -Force -Repository "PSGallery"
			}
			Else
			{
				$needsup = $true
				$vercheck = Find-module SharePointPnPPowerShellonline -Repository PSGallery
				$curmod = Get-module -ListAvailable -Name SharePointPnPPowerShellonline
				Foreach ($cur in $curmod)
				{
					If ([System.Version]$cur.Version -eq [System.Version]$vercheck.Version)
					{
						$needsup = $false
						Break
					}
					Else
					{
						Continue
					}
				}
				If ($needsup)
				{
					Update-Module SharePointPnPPowerShell* -Force
				}
				Else
				{
					Write-Host "All good."
				}
			}
			If (!(Test-Path $env:ProgramFiles\WindowsPowerShell\Modules\MSOnline))
			{
				Install-Module MSOnline -AllowClobber -Force -Repository "PSGallery"
			}
			Else
			{
				$needsup = $true
				$vercheck = Find-module MSOnline -Repository PSGallery
				$curmod = Get-module -ListAvailable -Name MSOnline
				Foreach ($cur in $curmod)
				{
					If ([System.Version]$cur.Version -eq [System.Version]$vercheck.Version)
					{
						$needsup = $false
						Break
					}
					Else
					{
						Continue
					}
				}
				If ($needsup)
				{
					Update-Module MSOnline -Force
				}
				Else
				{
					Write-Host "All good."
				}
			}
			If (!(Test-Path "$env:ProgramFiles\WindowsPowerShell\Modules\Microsoft.Online.SharePoint.PowerShell"))
			{
				Install-module Microsoft.Online.SharePoint.PowerShell -Force -AllowClobber -Repository "PSGallery"
			}
			Else
			{
				$needsup = $true
				$vercheck = Find-module Microsoft.Online.SharePoint.PowerShell -Repository PSGallery
				$curmod = Get-module -ListAvailable -Name Microsoft.Online.SharePoint.PowerShell
				Foreach ($cur in $curmod)
				{
					If ([System.Version]$cur.Version -eq [System.Version]$vercheck.Version)
					{
						$needsup = $false
						Break
					}
					Else
					{
						Continue
					}
				}
				If ($needsup)
				{
					Update-Module Microsoft.Online.SharePoint.PowerShell -Force
				}
				Else
				{
					Write-Host "All good."
				}
			}
			choco upgrade serviceassistant --source https://www.myget.org/F/serviceassistant/api/v2 -y
			try
			{
				update-thisscript -scriptdirp $ScriptDir -scriptnamp $scriptnamee
			}
			Catch
			{
				[System.Version]$scrivers = (Get-ItemProperty "$scriptdir\$scriptnamee.exe").VersionInfo.fileversion
				[System.Version]$fallback = Get-Content "\\cdcsrvr2\apps\BOX\version\$scriptnamee.txt"
				If ($scrivers -ne $fallback)
				{
					return "Wrong version"
				}
				Else
				{
					return "Something wrong"
				}
			}
	
			$secstt = ConvertTo-SecureString "blank" -AsPlainText -Force
			$creds = New-Object System.Management.Automation.PSCredential -ArgumentList "azbox", $secstt
			Connect-AzureRmAccount -Credential $creds
			$clientid = $null
			$clientsecret = $null
			$passphrase = $null
			$privatekey = $null
			$publickeyid = $null
			$enterpriseid = $null
			$clientid2 = $null
			$clientsecret2 = $null
			$passphrase2 = $null
			$privatekey2 = $null
			$publickeyid2 = $null
			$enterpriseid2 = $null
			$secrets = Get-AzureKeyVaultSecret -VaultName boxauth
			Foreach ($item in $secrets)
			{
				$azkey = Get-AzureKeyVaultSecret -name $item.Name -VaultName $item.VaultName
				If ($azkey.Name -like "clientID")
				{
					$clientid = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "clientSecret")
				{
					$clientsecret = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "passphrase")
				{
					$passphrase = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "privateKey")
				{
					$privatekey = $azkey.SecretValueText #.replace("\n","`n").ToString()
				}
				Elseif ($azkey.Name -like "publicKeyID")
				{
					$publickeyid = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "enterpriseID")
				{
					$enterpriseid = $azkey.SecretValueText
				}
				If ($azkey.Name -like "clientID2")
				{
					$clientid2 = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "clientSecret2")
				{
					$clientsecret2 = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "passphrase2")
				{
					$passphrase2 = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "privateKey2")
				{
					$privatekey2 = $azkey.SecretValueText #.replace("\n","`n").ToString()
				}
				Elseif ($azkey.Name -like "publicKeyID2")
				{
					$publickeyid2 = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "enterpriseID2")
				{
					$enterpriseid2 = $azkey.SecretValueText
				}
				Else
				{
				}
			}
			
			$boxconfig = New-Object -TypeName Box.V2.Config.Boxconfig($clientid, $clientSecret, $enterpriseID, $privateKey, $passphrase, $publicKeyID)
			$boxJWT = New-Object -TypeName Box.V2.JWTAuth.BoxJWTAuth($boxconfig)
			$boxjwt
			$tokenreal = $boxJWT.AdminToken()
			$adminclient = $boxjwt.AdminClient($tokenreal, "401268528")
			$adminclient
			
			$boxconfig2 = New-Object -TypeName Box.V2.Config.Boxconfig($clientid2, $clientSecret2, $enterpriseID2, $privateKey2, $passphrase2, $publicKeyID2)
			$boxJWT2 = New-Object -TypeName Box.V2.JWTAuth.BoxJWTAuth($boxconfig2)
			$boxjwt2
			$tokenreal2 = $boxJWT2.AdminToken()
			$adminclient2 = $boxjwt2.AdminClient($tokenreal2, "401268528")
			$adminclient2
			$number = $adminclient.UsersManager.GetEnterpriseUsersAsync($null, 0, 1000)
			$number.Wait()
			return [int]$number.Result.TotalCount
		} -CompletedScript {
			param ($job)
			Add-Type -AssemblyName System.Windows.Forms
			$results = Receive-Job -Job $job | Select-Object -Last 1
			If ($results -is [string])
			{
				If ($results -like "Wrong version")
				{
					Stop-JobTracker
					[void][System.Windows.Forms.MessageBox]::Show('For some reason, the script failed the auto-update process.  The script you are running is not the latest version.  Please manually download the latest version of the script from teams and re-run the script.', 'New version available', 'OK', 'Information') # Casting the method to [void] suppresses the output. 
					Get-Process -Name $scriptname | Stop-Process -Force
					throw "Download new version"
					Exit
				}
				else
				{
					Stop-JobTracker
					[void][System.Windows.Forms.MessageBox]::Show('An unknown error has occurred, as the script has failed the auto-update process.  Sources indicate that you are running the correct version of the script, so please let William Higgs know about this error.', 'Unknown error', 'OK', 'Information') # Casting the method to [void] suppresses the output. 
					Get-Process -Name $scriptname | Stop-Process -Force
					throw "Download new version"
					Exit
				}
			}
			Else
			{
				$global:totalcount = $results
				$labelaccount.Text = "$results of 2250 licenses used"
				If (2250 - [Int]$results -lt 10)
				{
					$labelaccount.ForeColor = 'Red'
				}
				Else
				{
					$labelaccount.ForeColor = 'Black'
				}
			}
			Import-Module DepartModule -Force
			
			$progressbaroverlay1.Visible = $false
			$button1.Enabled = $true
			$labelaccount.Visible = $true
			$textbox1.Enabled = $true
			$textbox2.Enabled = $true
			$listview1.Enabled = $true
			$buttonSearch.Enabled = $true
			$buttonAssignLicense.Enabled = $false
			$buttonRemoveBoxLicense.Enabled = $false
			$timer1.Enabled = $true
		} -ArgumentList $ScriptDirectory, $scriptname
	}
	
	#region Control Helper Functions
	function Update-ListViewColumnSort
	{
	<#
		.SYNOPSIS
			Sort the ListView's item using the specified column.
		
		.DESCRIPTION
			Sort the ListView's item using the specified column.
			This function uses Add-Type to define a class that sort the items.
			The ListView's Tag property is used to keep track of the sorting.
		
		.PARAMETER ListView
			The ListView control to sort.
		
		.PARAMETER ColumnIndex
			The index of the column to use for sorting.
		
		.PARAMETER SortOrder
			The direction to sort the items. If not specified or set to None, it will toggle.
		
		.EXAMPLE
			Update-ListViewColumnSort -ListView $listview1 -ColumnIndex 0
		
		.NOTES
			Additional information about the function.
	#>
		
		param
		(
			[Parameter(Mandatory = $true)]
			[ValidateNotNull()]
			[System.Windows.Forms.ListView]$ListView,
			[Parameter(Mandatory = $true)]
			[int]$ColumnIndex,
			[System.Windows.Forms.SortOrder]$SortOrder = 'None'
		)
		
		if (($ListView.Items.Count -eq 0) -or ($ColumnIndex -lt 0) -or ($ColumnIndex -ge $ListView.Columns.Count))
		{
			return;
		}
		
		#region Define ListViewItemComparer
		try
		{
			[ListViewItemComparer] | Out-Null
		}
		catch
		{
			Add-Type -ReferencedAssemblies ('System.Windows.Forms') -TypeDefinition @" 
	using System;
	using System.Windows.Forms;
	using System.Collections;
	public class ListViewItemComparer : IComparer
	{
	    public int column;
	    public SortOrder sortOrder;
	    public ListViewItemComparer()
	    {
	        column = 0;
			sortOrder = SortOrder.Ascending;
	    }
	    public ListViewItemComparer(int column, SortOrder sort)
	    {
	        this.column = column;
			sortOrder = sort;
	    }
	    public int Compare(object x, object y)
	    {
			if(column >= ((ListViewItem)x).SubItems.Count)
				return  sortOrder == SortOrder.Ascending ? -1 : 1;
		
			if(column >= ((ListViewItem)y).SubItems.Count)
				return sortOrder == SortOrder.Ascending ? 1 : -1;
		
			if(sortOrder == SortOrder.Ascending)
	        	return String.Compare(((ListViewItem)x).SubItems[column].Text, ((ListViewItem)y).SubItems[column].Text);
			else
				return String.Compare(((ListViewItem)y).SubItems[column].Text, ((ListViewItem)x).SubItems[column].Text);
	    }
	}
"@ | Out-Null
		}
		#endregion
		
		if ($ListView.Tag -is [ListViewItemComparer])
		{
			#Toggle the Sort Order
			if ($SortOrder -eq [System.Windows.Forms.SortOrder]::None)
			{
				if ($ListView.Tag.column -eq $ColumnIndex -and $ListView.Tag.sortOrder -eq 'Ascending')
				{
					$ListView.Tag.sortOrder = 'Descending'
				}
				else
				{
					$ListView.Tag.sortOrder = 'Ascending'
				}
			}
			else
			{
				$ListView.Tag.sortOrder = $SortOrder
			}
			
			$ListView.Tag.column = $ColumnIndex
			$ListView.Sort() #Sort the items
		}
		else
		{
			if ($SortOrder -eq [System.Windows.Forms.SortOrder]::None)
			{
				$SortOrder = [System.Windows.Forms.SortOrder]::Ascending
			}
			
			#Set to Tag because for some reason in PowerShell ListViewItemSorter prop returns null
			$ListView.Tag = New-Object ListViewItemComparer ($ColumnIndex, $SortOrder)
			$ListView.ListViewItemSorter = $ListView.Tag #Automatically sorts
		}
	}
	
	
	function Add-ListViewItem
	{
	<#
		.SYNOPSIS
			Adds the item(s) to the ListView and stores the object in the ListViewItem's Tag property.
	
		.DESCRIPTION
			Adds the item(s) to the ListView and stores the object in the ListViewItem's Tag property.
	
		.PARAMETER ListView
			The ListView control to add the items to.
	
		.PARAMETER Items
			The object or objects you wish to load into the ListView's Items collection.
			
		.PARAMETER  ImageIndex
			The index of a predefined image in the ListView's ImageList.
		
		.PARAMETER  SubItems
			List of strings to add as Subitems.
		
		.PARAMETER Group
			The group to place the item(s) in.
		
		.PARAMETER Clear
			This switch clears the ListView's Items before adding the new item(s).
		
		.EXAMPLE
			Add-ListViewItem -ListView $listview1 -Items "Test" -Group $listview1.Groups[0] -ImageIndex 0 -SubItems "Installed"
	#>
		
		Param (
			[ValidateNotNull()]
			[Parameter(Mandatory = $true)]
			[System.Windows.Forms.ListView]$ListView,
			[ValidateNotNull()]
			[Parameter(Mandatory = $true)]
			$Items,
			[int]$ImageIndex = -1,
			[string[]]$SubItems,
			$Group,
			[switch]$Clear)
		
		if ($Clear)
		{
			$ListView.Items.Clear();
		}
		
		$lvGroup = $null
		if ($Group -is [System.Windows.Forms.ListViewGroup])
		{
			$lvGroup = $Group
		}
		elseif ($Group -is [string])
		{
			#$lvGroup = $ListView.Group[$Group] # Case sensitive
			foreach ($groupItem in $ListView.Groups)
			{
				if ($groupItem.Name -eq $Group)
				{
					$lvGroup = $groupItem
					break
				}
			}
			
			if ($null -eq $lvGroup)
			{
				$lvGroup = $ListView.Groups.Add($Group, $Group)
			}
		}
		
		if ($Items -is [Array])
		{
			$ListView.BeginUpdate()
			foreach ($item in $Items)
			{
				$listitem = $ListView.Items.Add($item.ToString(), $ImageIndex)
				#Store the object in the Tag
				$listitem.Tag = $item
				
				if ($null -ne $SubItems)
				{
					$listitem.SubItems.AddRange($SubItems)
				}
				
				if ($null -ne $lvGroup)
				{
					$listitem.Group = $lvGroup
				}
			}
			$ListView.EndUpdate()
		}
		else
		{
			#Add a new item to the ListView
			$listitem = $ListView.Items.Add($Items.ToString(), $ImageIndex)
			#Store the object in the Tag
			$listitem.Tag = $Items
			
			if ($null -ne $SubItems)
			{
				$listitem.SubItems.AddRange($SubItems)
			}
			
			if ($null -ne $lvGroup)
			{
				$listitem.Group = $lvGroup
			}
		}
	}
	
	#endregion
	
	$timerJobTracker_Tick={
		#TODO: Place custom script here
		Update-JobTracker
	}
	
	$formBoxUserManagement_FormClosed=[System.Windows.Forms.FormClosedEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.FormClosedEventArgs]
		#TODO: Place custom script here
		Stop-JobTracker
	}
	
	$button1_Click={
		#TODO: Place custom script here
		$text = (Search-User).FetchedAttributes
		#only enables the "start" button (which is initially disabled) if a valid object was returned by the search-user function.
		If (($text -ne '') -and ($text -ne $null))
		{
			$textbox1.Text = $text
		}
		If (($textbox1.Text -ne '') -and ($textbox1.Text -ne $null) -and ($global:totalcount -lt 2250))
		{
			$buttonAssignLicense.Enabled = $true
		}
		Else
		{
			$buttonAssignLicense.Enabled = $false
		}
	}
	
	$buttonAssignLicense_Click={
		#TODO: Place custom script here
		$rtext = $textbox1.Text
		$textbox1.Clear()
		$progressbaroverlay1.Visible = $true
		$labelaccount.Visible = $false
		$textbox2.Enabled = $false
		$listview1.Enabled = $false
		$button1.Enabled = $false
		$buttonSearch.Enabled = $false
		$buttonAssignLicense.Enabled = $false
		$buttonRemoveBoxLicense.Enabled = $false
		$timer1.Enabled = $false
		
		Add-JobTracker -Name "Assign" -JobScript {
			param ($rrtext)
			Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			Import-Module DepartModule -Force
			$aduser = Get-ADUser $rrtext -Properties *
			$secstt = ConvertTo-SecureString "blank" -AsPlainText -Force
			$creds = New-Object System.Management.Automation.PSCredential -ArgumentList "azbox", $secstt
			Connect-AzureRmAccount -Credential $creds
			$clientid = $null
			$clientsecret = $null
			$passphrase = $null
			$privatekey = $null
			$publickeyid = $null
			$enterpriseid = $null
			$clientid2 = $null
			$clientsecret2 = $null
			$passphrase2 = $null
			$privatekey2 = $null
			$publickeyid2 = $null
			$enterpriseid2 = $null
			$secrets = Get-AzureKeyVaultSecret -VaultName boxauth
			Foreach ($item in $secrets)
			{
				$azkey = Get-AzureKeyVaultSecret -name $item.Name -VaultName $item.VaultName
				If ($azkey.Name -like "clientID")
				{
					$clientid = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "clientSecret")
				{
					$clientsecret = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "passphrase")
				{
					$passphrase = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "privateKey")
				{
					$privatekey = $azkey.SecretValueText #.replace("\n","`n").ToString()
				}
				Elseif ($azkey.Name -like "publicKeyID")
				{
					$publickeyid = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "enterpriseID")
				{
					$enterpriseid = $azkey.SecretValueText
				}
				If ($azkey.Name -like "clientID2")
				{
					$clientid2 = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "clientSecret2")
				{
					$clientsecret2 = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "passphrase2")
				{
					$passphrase2 = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "privateKey2")
				{
					$privatekey2 = $azkey.SecretValueText #.replace("\n","`n").ToString()
				}
				Elseif ($azkey.Name -like "publicKeyID2")
				{
					$publickeyid2 = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "enterpriseID2")
				{
					$enterpriseid2 = $azkey.SecretValueText
				}
				Else
				{
				}
			}
			
			$boxconfig = New-Object -TypeName Box.V2.Config.Boxconfig($clientid, $clientSecret, $enterpriseID, $privateKey, $passphrase, $publicKeyID)
			$boxJWT = New-Object -TypeName Box.V2.JWTAuth.BoxJWTAuth($boxconfig)
			$boxjwt
			$tokenreal = $boxJWT.AdminToken()
			$adminclient = $boxjwt.AdminClient($tokenreal, "401268528")
			$adminclient
			
			$boxconfig2 = New-Object -TypeName Box.V2.Config.Boxconfig($clientid2, $clientSecret2, $enterpriseID2, $privateKey2, $passphrase2, $publicKeyID2)
			$boxJWT2 = New-Object -TypeName Box.V2.JWTAuth.BoxJWTAuth($boxconfig2)
			$boxjwt2
			$tokenreal2 = $boxJWT2.AdminToken()
			$adminclient2 = $boxjwt2.AdminClient($tokenreal2, "401268528")
			$adminclient2
			$thenumber = $adminclient.UsersManager.GetEnterpriseUsersAsync($null, 0, 1000)
			$thenumber.Wait()
			$curnumber = $thenumber.Result.TotalCount
			If ($curnumber -eq 2247)
			{
				return "Forbidden"
			}
			Else
			{
				$haslis = $adminclient.UsersManager.GetEnterpriseUsersAsync($aduser.Mail, 0, 1000)
				$haslis.Wait()
				$psob = New-Object -TypeName System.Management.Automation.PSObject
				$psob | Add-Member -MemberType NoteProperty -Name "Current" -Value $curnumber
				If ([Int]$haslis.Result.TotalCount -eq 0)
				{
					$object = New-Object Box.V2.Models.BoxUserRequest
					$object.Name = $aduser.DisplayName
					$object.Login = $aduser.Mail
					$newuser = $adminclient.UsersManager.CreateEnterpriseUserAsync($object)
					$newuser.Wait()
					If ($newuser.Status -like "RanToCompletion")
					{
						Add-ADGroupMember -Identity "Federate - Box" -Members $rrtext -Confirm:$false
						return $newuser.Result
					}
					Else
					{
						If ($newuser.Exception.InnerException -like "*User with the specified login already exists*")
						{
							$enterprise = New-Object Box.V2.Models.BoxRequestEntity
							$enterprise.Id = $enterpriseid
							$enterprise.Type = "enterprise"
							$action = New-Object Box.V2.Models.BoxActionableByRequest
							$action.Login = $aduser.Mail
							$invite = New-Object Box.V2.Models.BoxUserInviteRequest
							$invite.ActionableBy = $action
							$invite.Enterprise = $enterprise
							$inviteaction = $adminclient.UsersManager.InviteUserToEnterpriseAsync($invite)
							$inviteaction.Wait()
							If ($inviteaction.Status -like "RanToCompletion")
							{
								Add-ADGroupMember -Identity "Federate - Box" -Members $rrtext -Confirm:$false
								return "User was invited to Acuity"
							}
							Else
							{
								return "An unknown error has occurred."
							}
						}
						Else
						{
							return "The user account creation failed"
						}
					}
				}
				Else
				{
					return "The email address associated with the user account you selected is already associated with an active box account."
				}
			}
		} -CompletedScript {
			param ($job)
			$recei = Receive-Job -Job $job | Select-Object -Last 1
			If ($recei -is [System.String])
			{
				If ($recei -like "Forbidden")
				{
					[void][System.Windows.Forms.MessageBox]::Show('To ensure that Acuity does not exceed the number of box licenses available and to ensure that there are licenses available for the migration off of box, you are unable to assign any more licenses until more licenses are available.  Please free up a box license.', 'Error', 'OK', 'Error') # Casting the method to [void] suppresses the output. 
					$button1.Enabled = $false
					$textbox1.Text = "Make more licenses available before assigning more."
				}
				elseif (($recei -like "An unknown error has occurred.") -or ($recei -like "The user account creation failed"))
				{
					[void][System.Windows.Forms.MessageBox]::Show('There was an error when attempting to create the box user account.  Please try closing this tool and re-running it.  If you continue to encounter errors, see help file.', 'Error', 'OK', 'Error') # Casting the method to [void] suppresses the output. 
				}
				elseif ($recei -like "User was invited to Acuity")
				{
					[void][System.Windows.Forms.MessageBox]::Show('The email address associated with the user account you selected is already associated with an external box account, so they have been invited to upgrade to an acuity box account, which they can accept the next time they login to box.', 'Success', 'OK', 'Information') # Casting the method to [void] suppresses the output. 
				}
				Else
				{
					[void][System.Windows.Forms.MessageBox]::Show('The email address associated with the user account you selected is already associated with an active box account.', 'Error', 'OK', 'Error') # Casting the method to [void] suppresses the output. 
				}
			}
			Else
			{
				[void][System.Windows.Forms.MessageBox]::Show("The following user account was created:`nName:`t$($recei.Name)`nlogin:`t$($recei.login)`nID:`t$($recei.Id)", 'Sucess', 'OK', 'Information') # Casting the method to [void] suppresses the output. 
				$global:totalcount = $global:totalcount + 1
				$labelaccount.Text = "$global:totalcount of 2250 licenses used"
				If (2250 - $global:totalcount -lt 10)
				{
					$labelaccount.ForeColor = 'Red'
				}
				Else
				{
					$labelaccount.ForeColor = 'Black'
				}
			}
			$labelaccount.Visible = $true
			$progressbaroverlay1.Visible = $false
			$textbox2.Enabled = $true
			$listview1.Enabled = $true
			$timer1.Enabled = $true
			$button1.Enabled = $true
			$buttonSearch.Enabled = $true
			$buttonAssignLicense.Enabled = $false
			$buttonRemoveBoxLicense.Enabled = $false
		} -ArgumentList $rtext
	}
	
	$buttonSearch_Click={
		#TODO: Place custom script here
		$querytext = $textbox2.Text
		$textbox2.Clear()
		$progressbaroverlay1.Visible = $true
		$labelaccount.Visible = $false
		$listview1.Enabled = $true
		$button1.Enabled = $false
		$buttonSearch.Enabled = $false
		$buttonAssignLicense.Enabled = $false
		$buttonRemoveBoxLicense.Enabled = $false
		$listview1.Items.Clear()
		
		Add-JobTracker -Name "Find" -JobScript {
			param ($queryy)
			Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			Import-Module DepartModule -Force
			$secstt = ConvertTo-SecureString "blank" -AsPlainText -Force
			$creds = New-Object System.Management.Automation.PSCredential -ArgumentList "azbox", $secstt
			Connect-AzureRmAccount -Credential $creds
			$clientid = $null
			$clientsecret = $null
			$passphrase = $null
			$privatekey = $null
			$publickeyid = $null
			$enterpriseid = $null
			$clientid2 = $null
			$clientsecret2 = $null
			$passphrase2 = $null
			$privatekey2 = $null
			$publickeyid2 = $null
			$enterpriseid2 = $null
			$secrets = Get-AzureKeyVaultSecret -VaultName boxauth
			Foreach ($item in $secrets)
			{
				$azkey = Get-AzureKeyVaultSecret -name $item.Name -VaultName $item.VaultName
				If ($azkey.Name -like "clientID")
				{
					$clientid = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "clientSecret")
				{
					$clientsecret = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "passphrase")
				{
					$passphrase = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "privateKey")
				{
					$privatekey = $azkey.SecretValueText #.replace("\n","`n").ToString()
				}
				Elseif ($azkey.Name -like "publicKeyID")
				{
					$publickeyid = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "enterpriseID")
				{
					$enterpriseid = $azkey.SecretValueText
				}
				If ($azkey.Name -like "clientID2")
				{
					$clientid2 = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "clientSecret2")
				{
					$clientsecret2 = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "passphrase2")
				{
					$passphrase2 = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "privateKey2")
				{
					$privatekey2 = $azkey.SecretValueText #.replace("\n","`n").ToString()
				}
				Elseif ($azkey.Name -like "publicKeyID2")
				{
					$publickeyid2 = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "enterpriseID2")
				{
					$enterpriseid2 = $azkey.SecretValueText
				}
				Else
				{
				}
			}
			
			$boxconfig = New-Object -TypeName Box.V2.Config.Boxconfig($clientid, $clientSecret, $enterpriseID, $privateKey, $passphrase, $publicKeyID)
			$boxJWT = New-Object -TypeName Box.V2.JWTAuth.BoxJWTAuth($boxconfig)
			$boxjwt
			$tokenreal = $boxJWT.AdminToken()
			$adminclient = $boxjwt.AdminClient($tokenreal, "401268528")
			$adminclient
			
			$boxconfig2 = New-Object -TypeName Box.V2.Config.Boxconfig($clientid2, $clientSecret2, $enterpriseID2, $privateKey2, $passphrase2, $publicKeyID2)
			$boxJWT2 = New-Object -TypeName Box.V2.JWTAuth.BoxJWTAuth($boxconfig2)
			$boxjwt2
			$tokenreal2 = $boxJWT2.AdminToken()
			$adminclient2 = $boxjwt2.AdminClient($tokenreal2, "401268528")
			$adminclient2
			$holdint = 0
			$holdsearch = New-Object System.Collections.ArrayList
			If (($queryy -like '') -or ($queryy -eq $null))
			{
				Do
				{
					$matacc = $adminclient.UsersManager.GetEnterpriseUsersAsync($null, $holdint, 1000)
					$matacc.Wait()
					foreach ($entry in $matacc.Result.entries)
					{
						$holdsearch.Add($entry)
					}
					$holdint = $holdint + 1000
				}
				Until ($holdint -gt $matacc.Result.TotalCount)
			}
			Else
			{
				$matacc = $adminclient.UsersManager.GetEnterpriseUsersAsync($queryy, 0, 1000)
				$matacc.Wait()
				foreach ($entry in $matacc.Result.entries)
				{
					$holdsearch.Add($entry)
				}
			}
			#If ($matacc.Status -like "RanToCompletion")
			#{
			#If ([int]$matacc.Result.TotalCount -gt 0)
			If ($holdsearch.Count -gt 0)
				{
					foreach ($thing in $holdsearch)
					{
						$size = $null
						switch ($thing.SpaceUsed)
						{
							0 { $size = 0 }
							{ 1 .. 1023 -contains $_ } { $size = "$_ bytes" }
							{ 1024 .. 1048575 -contains $_ } {
								$divide = [int]$_ / 1024
								$divide = [System.Math]::Round($divide,2)
								$size = "$divide KB"
							}
							#{ 1048576 .. 1073741823 -contains $_ } {
							{ ($_ -gt 1048575) -and ($_ -lt 1073741824) } {
								$divide = [int]$_ / 1048576
								$divide = [System.Math]::Round($divide, 2)
								$size = "$divide MB"
							}
							Default
							{
								[double]$divide = [System.Numerics.BigInteger]$_ / 1073741824
								$divide = [System.Math]::Round($divide, 2)
								$size = "$divide GB"
							}
						}
						$psob = New-Object -TypeName System.Management.Automation.PSObject
						$psob | Add-Member -MemberType NoteProperty -Name "Name" -Value $thing.Name
						$psob | Add-Member -MemberType NoteProperty -Name "Email" -Value $thing.login
						$psob | Add-Member -MemberType NoteProperty -Name "Created" -Value $thing.CreatedAt
						$psob | Add-Member -MemberType NoteProperty -Name "Modified" -Value $thing.ModifiedAt
						$psob | Add-Member -MemberType NoteProperty -Name "Size" -Value $size
						$psob
					}
				}
				Else
				{
					echo "No results"
				}
		} -CompletedScript {
			param ($job)
			$cool = Receive-Job -Job $job
			If ($cool[-1] -is [System.String])
			{
				Add-ListViewItem -ListView $listview1 -Items "error"
			}
			Else
			{
	
				foreach ($go in $cool)
				{
					If ($go -is [System.Management.Automation.PSObject])
					{
						Add-ListViewItem -ListView $listview1 -Items $go.Name -SubItems $go.Email, $go.Created, $go.Modified, $go.Size
					}
				}
			}
			$labelaccount.Visible = $true
			$progressbaroverlay1.Visible = $false
			$button1.Enabled = $true
			$buttonAssignLicense.Enabled = $false
			$buttonRemoveBoxLicense.Enabled = $false
			$buttonSearch.Enabled = $true
		} -ArgumentList $querytext
	}
	
	$listview1_SelectedIndexChanged={
		#TODO: Place custom script here
		If ($listview1.SelectedItems.Count -gt 0)
		{
			$buttonRemoveBoxLicense.Enabled = $true
		}
		Else
		{
			$buttonRemoveBoxLicense.Enabled = $false
		}
	}
	
	$buttonRemoveBoxLicense_Click={
		#TODO: Place custom script here
		$progressbaroverlay1.Visible = $true
		$labelaccount.Visible = $false
		$global:removecount = $listview1.SelectedItems.Count
		$listarray = ''
		foreach ($hilitem in $listview1.SelectedItems)
		{
			$listarray = $listarray + "$($hilitem.SubItems[1].Text),"
		}
		$listarray = $listarray.TrimEnd(',')
		$listview1.Items.Clear()
		$listview1.Enabled = $false
		$textbox2.Enabled = $false
		$buttonSearch.Enabled = $false
		$buttonAssignLicense.Enabled = $false
		$buttonRemoveBoxLicense.Enabled = $false
		$timer1.Enabled = $false
		Add-JobTracker -Name "remove" -JobScript {
			param ($listarr)
			Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			Import-Module DepartModule -Force
			$secstt = ConvertTo-SecureString "blank" -AsPlainText -Force
			$creds = New-Object System.Management.Automation.PSCredential -ArgumentList "azbox", $secstt
			Connect-AzureRmAccount -Credential $creds
			$clientid = $null
			$clientsecret = $null
			$passphrase = $null
			$privatekey = $null
			$publickeyid = $null
			$enterpriseid = $null
			$clientid2 = $null
			$clientsecret2 = $null
			$passphrase2 = $null
			$privatekey2 = $null
			$publickeyid2 = $null
			$enterpriseid2 = $null
			$secrets = Get-AzureKeyVaultSecret -VaultName boxauth
			Foreach ($item in $secrets)
			{
				$azkey = Get-AzureKeyVaultSecret -name $item.Name -VaultName $item.VaultName
				If ($azkey.Name -like "clientID")
				{
					$clientid = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "clientSecret")
				{
					$clientsecret = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "passphrase")
				{
					$passphrase = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "privateKey")
				{
					$privatekey = $azkey.SecretValueText #.replace("\n","`n").ToString()
				}
				Elseif ($azkey.Name -like "publicKeyID")
				{
					$publickeyid = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "enterpriseID")
				{
					$enterpriseid = $azkey.SecretValueText
				}
				If ($azkey.Name -like "clientID2")
				{
					$clientid2 = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "clientSecret2")
				{
					$clientsecret2 = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "passphrase2")
				{
					$passphrase2 = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "privateKey2")
				{
					$privatekey2 = $azkey.SecretValueText #.replace("\n","`n").ToString()
				}
				Elseif ($azkey.Name -like "publicKeyID2")
				{
					$publickeyid2 = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "enterpriseID2")
				{
					$enterpriseid2 = $azkey.SecretValueText
				}
				Else
				{
				}
			}
			
			$boxconfig = New-Object -TypeName Box.V2.Config.Boxconfig($clientid, $clientSecret, $enterpriseID, $privateKey, $passphrase, $publicKeyID)
			$boxJWT = New-Object -TypeName Box.V2.JWTAuth.BoxJWTAuth($boxconfig)
			$boxjwt
			$tokenreal = $boxJWT.AdminToken()
			$adminclient = $boxjwt.AdminClient($tokenreal, "401268528")
			$adminclient
			
			$boxconfig2 = New-Object -TypeName Box.V2.Config.Boxconfig($clientid2, $clientSecret2, $enterpriseID2, $privateKey2, $passphrase2, $publicKeyID2)
			$boxJWT2 = New-Object -TypeName Box.V2.JWTAuth.BoxJWTAuth($boxconfig2)
			$boxjwt2
			$tokenreal2 = $boxJWT2.AdminToken()
			$adminclient2 = $boxjwt2.AdminClient($tokenreal2, "401268528")
			$adminclient2
			
			$storefold = $adminclient.FoldersManager.GetFolderItemsAsync("48972200820", 1000, 0)
			$storefold.Wait()
			$foldarray = New-Object System.Collections.ArrayList
			foreach ($folder in $storefold.Result.entries)
			{
				$foldarray.Add($folder)
			}
			$newarray = $listarr.split(',')
			foreach ($account in $newarray)
			{
				$retdeluserinfo = $adminclient.UsersManager.GetEnterpriseUsersAsync($account, 0, 1000)
				$retdeluserinfo.Wait()
				If ($retdeluserinfo.Result.entries[0].SpaceUsed -ne 0)
				{
					$movecontent = $adminclient.UsersManager.MoveUserFolderAsync($retdeluserinfo.result.entries[0].Id, "401268528", "0")
					$movecontent.Wait()
					$thefold = $null
					$allfold = $adminclient.FoldersManager.GetFolderItemsAsync("0", 1000, 0)
					$allfold.Wait()
					foreach ($indfold in $allfold.Result.Entries)
					{
						If ($indfold.Name -like "$account*")
						{
							$thefold = $indfold.Id
							Break
						}
					}
					$storefold = $null
					$letter = $account.substring(0, 1)
					foreach ($instfold in $foldarray)
					{
						If ($letter.ToLower() -eq $instfold.Name.ToLower())
						{
							$storefold = $instfold.Id
							Break
						}
					}
					$folentreq = New-Object Box.V2.Models.BoxRequestEntity
					$folentreq.Id = $storefold
					$movefolreq = New-Object Box.V2.Models.BoxFolderRequest
					$movefolreq.Id = $thefold
					$movefolreq.Parent = $storefold
					$themove = $adminclient.FoldersManager.UpdateInformationAsync($movefolreq)
					$themove.Wait()
				}
				$deleteuser = $adminclient.UsersManager.DeleteEnterpriseUserAsync($retdeluserinfo.result.entries[0].Id, $false, $true)
				$deleteuser.Wait()
				$remuser = Get-ADUser -Filter "Mail -like `"$account`"" -Properties *
				Remove-ADGroupMember -Identity "Federate - Box" -Members $remuser.SamAccountName -Confirm:$false
				$deleteuser
			}
			#$useracc = $adminclient.UsersManager.GetEnterpriseUsersAsync("$($account.Subitems[0].Text)", 0, 1000)
				#$useracc.Wait()
		} -CompletedScript {
			param ($job)
			$recremjob = Receive-Job -Job $job | Select-Object -Last 1
			If ($recremjob.Status -like "RanToCompletion")
			{
				$global:totalcount = $global:totalcount - $global:removecount
				$labelaccount.Text = "$global:totalcount of 2250 licenses used"
				If (2250 - $global:totalcount -lt 10)
				{
					$labelaccount.ForeColor = 'Red'
				}
				Else
				{
					$labelaccount.ForeColor = 'Black'
				}
				If ($global:totalcount -ge 2247)
				{
					$button1.Enabled = $false
					$textbox1.Text = "Make more licenses available before assigning more."
				}
				Else
				{
					$button1.Enabled = $true
					If ($textbox1.Text -like "Make more licenses available before assigning more.")
					{
						$textbox1.Clear()
					}
				}
				Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show("The selected box account(s) have been successfully deleted.", "Success", 'OK', 'Information') # Casting the method to [void] suppresses the output. 
			}
			Else
			{
				Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show("There was an error deleting one or more of the box accounts.", "Error", 'OK', 'Error') # Casting the method to [void] suppresses the output. 
			}
			$labelaccount.Visible = $true
			$progressbaroverlay1.Visible = $false
			$button1.Enabled = $true
			$buttonAssignLicense.Enabled = $false
			$buttonRemoveBoxLicense.Enabled = $false
			$buttonSearch.Enabled = $true
			$textbox2.Enabled = $true
			$listview1.Enabled = $true
			$timer1.Enabled = $true
		} -ArgumentList $listarray
	}
	$timer1_Tick={
		#TODO: Place custom script here
		Add-JobTracker -Name "Refreshcount" -JobScript {
			Import-Module DepartModule -Force
			$secstt = ConvertTo-SecureString "blank" -AsPlainText -Force
			$creds = New-Object System.Management.Automation.PSCredential -ArgumentList "azbox", $secstt
			Connect-AzureRmAccount -Credential $creds
			$clientid = $null
			$clientsecret = $null
			$passphrase = $null
			$privatekey = $null
			$publickeyid = $null
			$enterpriseid = $null
			$clientid2 = $null
			$clientsecret2 = $null
			$passphrase2 = $null
			$privatekey2 = $null
			$publickeyid2 = $null
			$enterpriseid2 = $null
			$secrets = Get-AzureKeyVaultSecret -VaultName boxauth
			Foreach ($item in $secrets)
			{
				$azkey = Get-AzureKeyVaultSecret -name $item.Name -VaultName $item.VaultName
				If ($azkey.Name -like "clientID")
				{
					$clientid = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "clientSecret")
				{
					$clientsecret = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "passphrase")
				{
					$passphrase = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "privateKey")
				{
					$privatekey = $azkey.SecretValueText #.replace("\n","`n").ToString()
				}
				Elseif ($azkey.Name -like "publicKeyID")
				{
					$publickeyid = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "enterpriseID")
				{
					$enterpriseid = $azkey.SecretValueText
				}
				If ($azkey.Name -like "clientID2")
				{
					$clientid2 = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "clientSecret2")
				{
					$clientsecret2 = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "passphrase2")
				{
					$passphrase2 = $azkey.SecretValueText
				}
				ElseIf ($azkey.Name -like "privateKey2")
				{
					$privatekey2 = $azkey.SecretValueText #.replace("\n","`n").ToString()
				}
				Elseif ($azkey.Name -like "publicKeyID2")
				{
					$publickeyid2 = $azkey.SecretValueText
				}
				Elseif ($azkey.Name -like "enterpriseID2")
				{
					$enterpriseid2 = $azkey.SecretValueText
				}
				Else
				{
				}
			}
			
			$boxconfig = New-Object -TypeName Box.V2.Config.Boxconfig($clientid, $clientSecret, $enterpriseID, $privateKey, $passphrase, $publicKeyID)
			$boxJWT = New-Object -TypeName Box.V2.JWTAuth.BoxJWTAuth($boxconfig)
			$boxjwt
			$tokenreal = $boxJWT.AdminToken()
			$adminclient = $boxjwt.AdminClient($tokenreal, "401268528")
			$adminclient
			
			$boxconfig2 = New-Object -TypeName Box.V2.Config.Boxconfig($clientid2, $clientSecret2, $enterpriseID2, $privateKey2, $passphrase2, $publicKeyID2)
			$boxJWT2 = New-Object -TypeName Box.V2.JWTAuth.BoxJWTAuth($boxconfig2)
			$boxjwt2
			$tokenreal2 = $boxJWT2.AdminToken()
			$adminclient2 = $boxjwt2.AdminClient($tokenreal2, "401268528")
			$adminclient2
			$users = $adminclient.UsersManager.GetEnterpriseUsersAsync($null, 0, 1000)
			$users.Wait()
			return [int]$users.Result.TotalCount
		} -CompletedScript {
			param ($job)
			$reccount = Receive-Job -Job $job | Select-Object -Last 1
			If ($reccount -is [int])
			{
				$global:totalcount = $reccount
				$labelaccount.Text = "$reccount of 2250 licenses used"
				If ($global:totalcount -ge 2240)
				{
					$labelaccount.ForeColor = 'DarkRed'
				}
				Else
				{
					$labelaccount.ForeColor = 'Black'
				}
				If ($global:totalcount -ge 2247)
				{
					$button1.Enabled = $false
					$textbox1.Text = "Make more licenses available before assigning more."
				}
				Else
				{
					If ($progressbaroverlay1.Visible -eq $false)
					{
						$button1.Enabled = $true
						If ($textbox1.Text -like "Make more licenses available before assigning more.")
						{
							$textbox1.Clear()
						}
					}
				}
			}
		}
	}
	
	# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$formBoxUserManagement.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
		$script:MainForm_listview1 = $listview1.SelectedItems
		$script:MainForm_textbox2 = $textbox2.Text
		$script:MainForm_textbox1 = $textbox1.Text
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$buttonRemoveBoxLicense.remove_Click($buttonRemoveBoxLicense_Click)
			$listview1.remove_SelectedIndexChanged($listview1_SelectedIndexChanged)
			$buttonSearch.remove_Click($buttonSearch_Click)
			$buttonAssignLicense.remove_Click($buttonAssignLicense_Click)
			$button1.remove_Click($button1_Click)
			$formBoxUserManagement.remove_FormClosed($formBoxUserManagement_FormClosed)
			$formBoxUserManagement.remove_Load($formBoxUserManagement_Load)
			$timerJobTracker.remove_Tick($timerJobTracker_Tick)
			$timer1.remove_Tick($timer1_Tick)
			$formBoxUserManagement.remove_Load($Form_StateCorrection_Load)
			$formBoxUserManagement.remove_Closing($Form_StoreValues_Closing)
			$formBoxUserManagement.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch { Out-Null <# Prevent PSScriptAnalyzer warning #> }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$formBoxUserManagement.SuspendLayout()
	#
	# formBoxUserManagement
	#
	$formBoxUserManagement.Controls.Add($buttonRemoveBoxLicense)
	$formBoxUserManagement.Controls.Add($listview1)
	$formBoxUserManagement.Controls.Add($buttonSearch)
	$formBoxUserManagement.Controls.Add($textbox2)
	$formBoxUserManagement.Controls.Add($labelRemoveBoxLicense)
	$formBoxUserManagement.Controls.Add($buttonAssignLicense)
	$formBoxUserManagement.Controls.Add($button1)
	$formBoxUserManagement.Controls.Add($textbox1)
	$formBoxUserManagement.Controls.Add($labelCreateBoxAccount)
	$formBoxUserManagement.Controls.Add($labelBoxUserManagement)
	$formBoxUserManagement.Controls.Add($progressbaroverlay1)
	$formBoxUserManagement.Controls.Add($labelaccount)
	$formBoxUserManagement.AutoScaleDimensions = '6, 13'
	$formBoxUserManagement.AutoScaleMode = 'Font'
	$formBoxUserManagement.ClientSize = '571, 544'
	$formBoxUserManagement.Name = 'formBoxUserManagement'
	$formBoxUserManagement.Text = 'Box user management'
	$formBoxUserManagement.add_FormClosed($formBoxUserManagement_FormClosed)
	$formBoxUserManagement.add_Load($formBoxUserManagement_Load)
	#
	# buttonRemoveBoxLicense
	#
	$buttonRemoveBoxLicense.Enabled = $False
	$buttonRemoveBoxLicense.Location = '218, 509'
	$buttonRemoveBoxLicense.Name = 'buttonRemoveBoxLicense'
	$buttonRemoveBoxLicense.Size = '134, 23'
	$buttonRemoveBoxLicense.TabIndex = 11
	$buttonRemoveBoxLicense.Text = 'Remove Box license'
	$buttonRemoveBoxLicense.UseCompatibleTextRendering = $True
	$buttonRemoveBoxLicense.UseVisualStyleBackColor = $True
	$buttonRemoveBoxLicense.add_Click($buttonRemoveBoxLicense_Click)
	#
	# listview1
	#
	[void]$listview1.Columns.Add($columnheader1)
	[void]$listview1.Columns.Add($columnheader2)
	[void]$listview1.Columns.Add($columnheader3)
	[void]$listview1.Columns.Add($columnheader4)
	[void]$listview1.Columns.Add($columnheader5)
	$listview1.Enabled = $False
	$listview1.FullRowSelect = $True
	$listview1.GridLines = $True
	$listview1.HideSelection = $False
	$listview1.Location = '12, 181'
	$listview1.Name = 'listview1'
	$listview1.Size = '547, 321'
	$listview1.TabIndex = 10
	$listview1.UseCompatibleStateImageBehavior = $False
	$listview1.View = 'Details'
	$listview1.add_SelectedIndexChanged($listview1_SelectedIndexChanged)
	#
	# buttonSearch
	#
	$buttonSearch.Enabled = $False
	$buttonSearch.Location = '477, 154'
	$buttonSearch.Name = 'buttonSearch'
	$buttonSearch.Size = '75, 19'
	$buttonSearch.TabIndex = 9
	$buttonSearch.Text = 'Search'
	$buttonSearch.UseCompatibleTextRendering = $True
	$buttonSearch.UseVisualStyleBackColor = $True
	$buttonSearch.add_Click($buttonSearch_Click)
	#
	# textbox2
	#
	$textbox2.Enabled = $False
	$textbox2.Location = '153, 154'
	$textbox2.Name = 'textbox2'
	$textbox2.Size = '297, 20'
	$textbox2.TabIndex = 8
	#
	# labelRemoveBoxLicense
	#
	$labelRemoveBoxLicense.AutoSize = $True
	$labelRemoveBoxLicense.Font = 'Microsoft Sans Serif, 10pt'
	$labelRemoveBoxLicense.Location = '12, 155'
	$labelRemoveBoxLicense.Name = 'labelRemoveBoxLicense'
	$labelRemoveBoxLicense.Size = '134, 20'
	$labelRemoveBoxLicense.TabIndex = 7
	$labelRemoveBoxLicense.Text = 'Remove Box License'
	$labelRemoveBoxLicense.UseCompatibleTextRendering = $True
	#
	# buttonAssignLicense
	#
	$buttonAssignLicense.Enabled = $False
	$buttonAssignLicense.Font = 'Microsoft Sans Serif, 10pt'
	$buttonAssignLicense.Location = '223, 122'
	$buttonAssignLicense.Name = 'buttonAssignLicense'
	$buttonAssignLicense.Size = '125, 27'
	$buttonAssignLicense.TabIndex = 6
	$buttonAssignLicense.Text = 'Assign License'
	$buttonAssignLicense.UseCompatibleTextRendering = $True
	$buttonAssignLicense.UseVisualStyleBackColor = $True
	$buttonAssignLicense.add_Click($buttonAssignLicense_Click)
	#
	# button1
	#
	$button1.Enabled = $False
	$button1.Location = '477, 96'
	$button1.Name = 'button1'
	$button1.Size = '75, 20'
	$button1.TabIndex = 5
	$button1.Text = '....'
	$button1.UseCompatibleTextRendering = $True
	$button1.UseVisualStyleBackColor = $True
	$button1.add_Click($button1_Click)
	#
	# textbox1
	#
	$textbox1.Location = '146, 96'
	$textbox1.Name = 'textbox1'
	$textbox1.ReadOnly = $True
	$textbox1.Size = '304, 20'
	$textbox1.TabIndex = 4
	#
	# labelCreateBoxAccount
	#
	$labelCreateBoxAccount.AutoSize = $True
	$labelCreateBoxAccount.Font = 'Microsoft Sans Serif, 10pt'
	$labelCreateBoxAccount.Location = '12, 97'
	$labelCreateBoxAccount.Name = 'labelCreateBoxAccount'
	$labelCreateBoxAccount.Size = '127, 20'
	$labelCreateBoxAccount.TabIndex = 3
	$labelCreateBoxAccount.Text = 'Create Box Account'
	$labelCreateBoxAccount.UseCompatibleTextRendering = $True
	#
	# labelBoxUserManagement
	#
	$labelBoxUserManagement.AutoSize = $True
	$labelBoxUserManagement.Font = 'Microsoft Sans Serif, 16pt'
	$labelBoxUserManagement.Location = '169, 9'
	$labelBoxUserManagement.Name = 'labelBoxUserManagement'
	$labelBoxUserManagement.Size = '232, 30'
	$labelBoxUserManagement.TabIndex = 0
	$labelBoxUserManagement.Text = 'Box User Management'
	$labelBoxUserManagement.UseCompatibleTextRendering = $True
	#
	# progressbaroverlay1
	#
	$progressbaroverlay1.Location = '12, 43'
	$progressbaroverlay1.Name = 'progressbaroverlay1'
	$progressbaroverlay1.Size = '547, 23'
	$progressbaroverlay1.Style = 'Marquee'
	$progressbaroverlay1.TabIndex = 2
	$progressbaroverlay1.TextOverlay = 'Loading....'
	$progressbaroverlay1.UseWaitCursor = $True
	$progressbaroverlay1.Visible = $False
	#
	# labelaccount
	#
	$labelaccount.AutoSize = $True
	$labelaccount.Font = 'Microsoft Sans Serif, 12pt, style=Bold'
	$labelaccount.Location = '175, 43'
	$labelaccount.Name = 'labelaccount'
	$labelaccount.Size = '221, 24'
	$labelaccount.TabIndex = 1
	$labelaccount.Text = '0000 of 2250 Licenses Used'
	$labelaccount.UseCompatibleTextRendering = $True
	$labelaccount.Visible = $False
	#
	# columnheader1
	#
	$columnheader1.Text = 'Name'
	$columnheader1.Width = 120
	#
	# columnheader2
	#
	$columnheader2.Text = 'Email'
	$columnheader2.Width = 140
	#
	# columnheader3
	#
	$columnheader3.Text = 'Date Created'
	$columnheader3.Width = 100
	#
	# columnheader4
	#
	$columnheader4.Text = 'Date Modified'
	$columnheader4.Width = 100
	#
	# columnheader5
	#
	$columnheader5.Text = 'Space Used'
	$columnheader5.Width = 100
	#
	# timerJobTracker
	#
	$timerJobTracker.add_Tick($timerJobTracker_Tick)
	#
	# timer1
	#
	$timer1.Interval = 25000
	$timer1.add_Tick($timer1_Tick)
	$formBoxUserManagement.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $formBoxUserManagement.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$formBoxUserManagement.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$formBoxUserManagement.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$formBoxUserManagement.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $formBoxUserManagement.ShowDialog()

}
#endregion Source: MainForm.psf

#Start the application
Main ($CommandLine)
